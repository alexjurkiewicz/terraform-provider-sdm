// This file was generated by protogen. DO NOT EDIT.

package sdm

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/helper/schema"

	sdm "github.com/strongdm/strongdm-sdk-go"
)

func resourceResource() *schema.Resource {
	return &schema.Resource{
		Create: wrapCrudOperation(resourceResourceCreate),
		Read:   wrapCrudOperation(resourceResourceRead),
		Update: wrapCrudOperation(resourceResourceUpdate),
		Delete: wrapCrudOperation(resourceResourceDelete),
		Importer: &schema.ResourceImporter{
			State: schema.ImportStatePassthrough,
		},
		Schema: map[string]*schema.Schema{
			"athena": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"access_key": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"secret_access_key": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"output": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"region": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"big_query": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"private_key": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"project": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"cassandra": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"db_2_i": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"db_2_luw": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"druid": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"dynamo_db": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"access_key": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"secret_access_key": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
					},
				},
			},
			"amazon_es": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"secret_access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
					},
				},
			},
			"elastic": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"http_basic_auth": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"url": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"healthcheck_path": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"headers_blacklist": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"default_path": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
					},
				},
			},
			"http_no_auth": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"url": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"healthcheck_path": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"headers_blacklist": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"default_path": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
					},
				},
			},
			"http_auth": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"url": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"healthcheck_path": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"auth_header": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"headers_blacklist": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"default_path": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
					},
				},
			},
			"kubernetes": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"certificate_authority_filename": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"client_certificate": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"client_certificate_filename": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"client_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"client_key_filename": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"kubernetes_basic_auth": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"kubernetes_service_account": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"token": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"amazon_eks": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"access_key": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"secret_access_key": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"certificate_authority": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"certificate_authority_filename": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"cluster_name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"google_gke": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"certificate_authority": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"certificate_authority_filename": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"service_account_key": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"service_account_key_filename": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"aks": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"certificate_authority_filename": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"client_certificate": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"client_certificate_filename": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"client_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"client_key_filename": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"aks_basic_auth": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"aks_service_account": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"token": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"memcached": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"mongo_legacy_host": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"auth_database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"replica_set": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"mongo_legacy_replicaset": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"auth_database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"replica_set": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"connect_to_replica": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"mongo_host": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"auth_database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"mongo_replica_set": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"auth_database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"replica_set": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"connect_to_replica": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"mysql": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"aurora_mysql": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"clustrix": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"maria": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"memsql": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"oracle": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"postgres": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"aurora_postgres": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"greenplum": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"cockroach": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"redshift": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"citus": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"presto": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"rdp": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
					},
				},
			},
			"redis": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"elasticache_redis": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"snowflake": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"schema": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
					},
				},
			},
			"sql_server": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"schema": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"ssh": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"public_key": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "",
						},
						"port_forwarding": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"allow_deprecated_key_exchanges": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"ssh_cert": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"port_forwarding": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"allow_deprecated_key_exchanges": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"sybase": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
					},
				},
			},
			"sybase_iq": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
					},
				},
			},
			"teradata": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"tags": {
							Type: schema.TypeMap,

							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Required:    true,
							Sensitive:   true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
		},
		Timeouts: &schema.ResourceTimeout{
			Default: schema.DefaultTimeout(60 * time.Second),
		},
	}
}
func convertResourceFromResourceData(d *schema.ResourceData) sdm.Resource {
	if list := d.Get("athena").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Athena{}
		}
		out := &sdm.Athena{
			ID:              d.Id(),
			Name:            convertStringFromMap(raw, "name"),
			Tags:            convertTagsFromMap(raw, "tags"),
			AccessKey:       convertStringFromMap(raw, "access_key"),
			SecretAccessKey: convertStringFromMap(raw, "secret_access_key"),
			Output:          convertStringFromMap(raw, "output"),
			Region:          convertStringFromMap(raw, "region"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("big_query").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.BigQuery{}
		}
		out := &sdm.BigQuery{
			ID:         d.Id(),
			Name:       convertStringFromMap(raw, "name"),
			Tags:       convertTagsFromMap(raw, "tags"),
			PrivateKey: convertStringFromMap(raw, "private_key"),
			Project:    convertStringFromMap(raw, "project"),
			Endpoint:   convertStringFromMap(raw, "endpoint"),
			Username:   convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("cassandra").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Cassandra{}
		}
		out := &sdm.Cassandra{
			ID:          d.Id(),
			Name:        convertStringFromMap(raw, "name"),
			Tags:        convertTagsFromMap(raw, "tags"),
			Hostname:    convertStringFromMap(raw, "hostname"),
			Username:    convertStringFromMap(raw, "username"),
			Password:    convertStringFromMap(raw, "password"),
			Port:        convertInt32FromMap(raw, "port"),
			TlsRequired: convertBoolFromMap(raw, "tls_required"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("db_2_i").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.DB2I{}
		}
		out := &sdm.DB2I{
			ID:          d.Id(),
			Name:        convertStringFromMap(raw, "name"),
			Tags:        convertTagsFromMap(raw, "tags"),
			Hostname:    convertStringFromMap(raw, "hostname"),
			Username:    convertStringFromMap(raw, "username"),
			Password:    convertStringFromMap(raw, "password"),
			Database:    convertStringFromMap(raw, "database"),
			Port:        convertInt32FromMap(raw, "port"),
			TlsRequired: convertBoolFromMap(raw, "tls_required"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("db_2_luw").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.DB2LUW{}
		}
		out := &sdm.DB2LUW{
			ID:       d.Id(),
			Name:     convertStringFromMap(raw, "name"),
			Tags:     convertTagsFromMap(raw, "tags"),
			Hostname: convertStringFromMap(raw, "hostname"),
			Username: convertStringFromMap(raw, "username"),
			Password: convertStringFromMap(raw, "password"),
			Database: convertStringFromMap(raw, "database"),
			Port:     convertInt32FromMap(raw, "port"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("druid").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Druid{}
		}
		out := &sdm.Druid{
			ID:       d.Id(),
			Name:     convertStringFromMap(raw, "name"),
			Tags:     convertTagsFromMap(raw, "tags"),
			Hostname: convertStringFromMap(raw, "hostname"),
			Username: convertStringFromMap(raw, "username"),
			Password: convertStringFromMap(raw, "password"),
			Port:     convertInt32FromMap(raw, "port"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("dynamo_db").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.DynamoDB{}
		}
		out := &sdm.DynamoDB{
			ID:              d.Id(),
			Name:            convertStringFromMap(raw, "name"),
			Tags:            convertTagsFromMap(raw, "tags"),
			AccessKey:       convertStringFromMap(raw, "access_key"),
			SecretAccessKey: convertStringFromMap(raw, "secret_access_key"),
			Region:          convertStringFromMap(raw, "region"),
			Endpoint:        convertStringFromMap(raw, "endpoint"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("amazon_es").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AmazonES{}
		}
		out := &sdm.AmazonES{
			ID:              d.Id(),
			Name:            convertStringFromMap(raw, "name"),
			Tags:            convertTagsFromMap(raw, "tags"),
			Region:          convertStringFromMap(raw, "region"),
			SecretAccessKey: convertStringFromMap(raw, "secret_access_key"),
			Endpoint:        convertStringFromMap(raw, "endpoint"),
			AccessKey:       convertStringFromMap(raw, "access_key"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("elastic").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Elastic{}
		}
		out := &sdm.Elastic{
			ID:          d.Id(),
			Name:        convertStringFromMap(raw, "name"),
			Tags:        convertTagsFromMap(raw, "tags"),
			Hostname:    convertStringFromMap(raw, "hostname"),
			Username:    convertStringFromMap(raw, "username"),
			Password:    convertStringFromMap(raw, "password"),
			Port:        convertInt32FromMap(raw, "port"),
			TlsRequired: convertBoolFromMap(raw, "tls_required"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("http_basic_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.HTTPBasicAuth{}
		}
		out := &sdm.HTTPBasicAuth{
			ID:               d.Id(),
			Name:             convertStringFromMap(raw, "name"),
			Tags:             convertTagsFromMap(raw, "tags"),
			Url:              convertStringFromMap(raw, "url"),
			HealthcheckPath:  convertStringFromMap(raw, "healthcheck_path"),
			Username:         convertStringFromMap(raw, "username"),
			Password:         convertStringFromMap(raw, "password"),
			HeadersBlacklist: convertStringFromMap(raw, "headers_blacklist"),
			DefaultPath:      convertStringFromMap(raw, "default_path"),
			Subdomain:        convertStringFromMap(raw, "subdomain"),
		}
		return out
	}
	if list := d.Get("http_no_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.HTTPNoAuth{}
		}
		out := &sdm.HTTPNoAuth{
			ID:               d.Id(),
			Name:             convertStringFromMap(raw, "name"),
			Tags:             convertTagsFromMap(raw, "tags"),
			Url:              convertStringFromMap(raw, "url"),
			HealthcheckPath:  convertStringFromMap(raw, "healthcheck_path"),
			HeadersBlacklist: convertStringFromMap(raw, "headers_blacklist"),
			DefaultPath:      convertStringFromMap(raw, "default_path"),
			Subdomain:        convertStringFromMap(raw, "subdomain"),
		}
		return out
	}
	if list := d.Get("http_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.HTTPAuth{}
		}
		out := &sdm.HTTPAuth{
			ID:               d.Id(),
			Name:             convertStringFromMap(raw, "name"),
			Tags:             convertTagsFromMap(raw, "tags"),
			Url:              convertStringFromMap(raw, "url"),
			HealthcheckPath:  convertStringFromMap(raw, "healthcheck_path"),
			AuthHeader:       convertStringFromMap(raw, "auth_header"),
			HeadersBlacklist: convertStringFromMap(raw, "headers_blacklist"),
			DefaultPath:      convertStringFromMap(raw, "default_path"),
			Subdomain:        convertStringFromMap(raw, "subdomain"),
		}
		return out
	}
	if list := d.Get("kubernetes").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Kubernetes{}
		}
		out := &sdm.Kubernetes{
			ID:                           d.Id(),
			Name:                         convertStringFromMap(raw, "name"),
			Tags:                         convertTagsFromMap(raw, "tags"),
			Hostname:                     convertStringFromMap(raw, "hostname"),
			Port:                         convertInt32FromMap(raw, "port"),
			CertificateAuthority:         convertStringFromMap(raw, "certificate_authority"),
			CertificateAuthorityFilename: convertStringFromMap(raw, "certificate_authority_filename"),
			ClientCertificate:            convertStringFromMap(raw, "client_certificate"),
			ClientCertificateFilename:    convertStringFromMap(raw, "client_certificate_filename"),
			ClientKey:                    convertStringFromMap(raw, "client_key"),
			ClientKeyFilename:            convertStringFromMap(raw, "client_key_filename"),
			HealthcheckNamespace:         convertStringFromMap(raw, "healthcheck_namespace"),
		}
		return out
	}
	if list := d.Get("kubernetes_basic_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.KubernetesBasicAuth{}
		}
		out := &sdm.KubernetesBasicAuth{
			ID:                   d.Id(),
			Name:                 convertStringFromMap(raw, "name"),
			Tags:                 convertTagsFromMap(raw, "tags"),
			Hostname:             convertStringFromMap(raw, "hostname"),
			Port:                 convertInt32FromMap(raw, "port"),
			Username:             convertStringFromMap(raw, "username"),
			Password:             convertStringFromMap(raw, "password"),
			HealthcheckNamespace: convertStringFromMap(raw, "healthcheck_namespace"),
		}
		return out
	}
	if list := d.Get("kubernetes_service_account").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.KubernetesServiceAccount{}
		}
		out := &sdm.KubernetesServiceAccount{
			ID:                   d.Id(),
			Name:                 convertStringFromMap(raw, "name"),
			Tags:                 convertTagsFromMap(raw, "tags"),
			Hostname:             convertStringFromMap(raw, "hostname"),
			Port:                 convertInt32FromMap(raw, "port"),
			Token:                convertStringFromMap(raw, "token"),
			HealthcheckNamespace: convertStringFromMap(raw, "healthcheck_namespace"),
		}
		return out
	}
	if list := d.Get("amazon_eks").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AmazonEKS{}
		}
		out := &sdm.AmazonEKS{
			ID:                           d.Id(),
			Name:                         convertStringFromMap(raw, "name"),
			Tags:                         convertTagsFromMap(raw, "tags"),
			Endpoint:                     convertStringFromMap(raw, "endpoint"),
			AccessKey:                    convertStringFromMap(raw, "access_key"),
			SecretAccessKey:              convertStringFromMap(raw, "secret_access_key"),
			CertificateAuthority:         convertStringFromMap(raw, "certificate_authority"),
			CertificateAuthorityFilename: convertStringFromMap(raw, "certificate_authority_filename"),
			Region:                       convertStringFromMap(raw, "region"),
			ClusterName:                  convertStringFromMap(raw, "cluster_name"),
			RoleArn:                      convertStringFromMap(raw, "role_arn"),
			HealthcheckNamespace:         convertStringFromMap(raw, "healthcheck_namespace"),
		}
		return out
	}
	if list := d.Get("google_gke").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.GoogleGKE{}
		}
		out := &sdm.GoogleGKE{
			ID:                           d.Id(),
			Name:                         convertStringFromMap(raw, "name"),
			Tags:                         convertTagsFromMap(raw, "tags"),
			Endpoint:                     convertStringFromMap(raw, "endpoint"),
			CertificateAuthority:         convertStringFromMap(raw, "certificate_authority"),
			CertificateAuthorityFilename: convertStringFromMap(raw, "certificate_authority_filename"),
			ServiceAccountKey:            convertStringFromMap(raw, "service_account_key"),
			ServiceAccountKeyFilename:    convertStringFromMap(raw, "service_account_key_filename"),
			HealthcheckNamespace:         convertStringFromMap(raw, "healthcheck_namespace"),
		}
		return out
	}
	if list := d.Get("aks").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AKS{}
		}
		out := &sdm.AKS{
			ID:                           d.Id(),
			Name:                         convertStringFromMap(raw, "name"),
			Tags:                         convertTagsFromMap(raw, "tags"),
			Hostname:                     convertStringFromMap(raw, "hostname"),
			Port:                         convertInt32FromMap(raw, "port"),
			CertificateAuthority:         convertStringFromMap(raw, "certificate_authority"),
			CertificateAuthorityFilename: convertStringFromMap(raw, "certificate_authority_filename"),
			ClientCertificate:            convertStringFromMap(raw, "client_certificate"),
			ClientCertificateFilename:    convertStringFromMap(raw, "client_certificate_filename"),
			ClientKey:                    convertStringFromMap(raw, "client_key"),
			ClientKeyFilename:            convertStringFromMap(raw, "client_key_filename"),
			HealthcheckNamespace:         convertStringFromMap(raw, "healthcheck_namespace"),
		}
		return out
	}
	if list := d.Get("aks_basic_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AKSBasicAuth{}
		}
		out := &sdm.AKSBasicAuth{
			ID:                   d.Id(),
			Name:                 convertStringFromMap(raw, "name"),
			Tags:                 convertTagsFromMap(raw, "tags"),
			Hostname:             convertStringFromMap(raw, "hostname"),
			Port:                 convertInt32FromMap(raw, "port"),
			Username:             convertStringFromMap(raw, "username"),
			Password:             convertStringFromMap(raw, "password"),
			HealthcheckNamespace: convertStringFromMap(raw, "healthcheck_namespace"),
		}
		return out
	}
	if list := d.Get("aks_service_account").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AKSServiceAccount{}
		}
		out := &sdm.AKSServiceAccount{
			ID:                   d.Id(),
			Name:                 convertStringFromMap(raw, "name"),
			Tags:                 convertTagsFromMap(raw, "tags"),
			Hostname:             convertStringFromMap(raw, "hostname"),
			Port:                 convertInt32FromMap(raw, "port"),
			Token:                convertStringFromMap(raw, "token"),
			HealthcheckNamespace: convertStringFromMap(raw, "healthcheck_namespace"),
		}
		return out
	}
	if list := d.Get("memcached").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Memcached{}
		}
		out := &sdm.Memcached{
			ID:       d.Id(),
			Name:     convertStringFromMap(raw, "name"),
			Tags:     convertTagsFromMap(raw, "tags"),
			Hostname: convertStringFromMap(raw, "hostname"),
			Port:     convertInt32FromMap(raw, "port"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("mongo_legacy_host").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.MongoLegacyHost{}
		}
		out := &sdm.MongoLegacyHost{
			ID:           d.Id(),
			Name:         convertStringFromMap(raw, "name"),
			Tags:         convertTagsFromMap(raw, "tags"),
			Hostname:     convertStringFromMap(raw, "hostname"),
			AuthDatabase: convertStringFromMap(raw, "auth_database"),
			Username:     convertStringFromMap(raw, "username"),
			Password:     convertStringFromMap(raw, "password"),
			Port:         convertInt32FromMap(raw, "port"),
			ReplicaSet:   convertStringFromMap(raw, "replica_set"),
			TlsRequired:  convertBoolFromMap(raw, "tls_required"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("mongo_legacy_replicaset").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.MongoLegacyReplicaset{}
		}
		out := &sdm.MongoLegacyReplicaset{
			ID:               d.Id(),
			Name:             convertStringFromMap(raw, "name"),
			Tags:             convertTagsFromMap(raw, "tags"),
			Hostname:         convertStringFromMap(raw, "hostname"),
			AuthDatabase:     convertStringFromMap(raw, "auth_database"),
			Username:         convertStringFromMap(raw, "username"),
			Password:         convertStringFromMap(raw, "password"),
			Port:             convertInt32FromMap(raw, "port"),
			ReplicaSet:       convertStringFromMap(raw, "replica_set"),
			ConnectToReplica: convertBoolFromMap(raw, "connect_to_replica"),
			TlsRequired:      convertBoolFromMap(raw, "tls_required"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("mongo_host").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.MongoHost{}
		}
		out := &sdm.MongoHost{
			ID:           d.Id(),
			Name:         convertStringFromMap(raw, "name"),
			Tags:         convertTagsFromMap(raw, "tags"),
			Hostname:     convertStringFromMap(raw, "hostname"),
			AuthDatabase: convertStringFromMap(raw, "auth_database"),
			Username:     convertStringFromMap(raw, "username"),
			Password:     convertStringFromMap(raw, "password"),
			Port:         convertInt32FromMap(raw, "port"),
			TlsRequired:  convertBoolFromMap(raw, "tls_required"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("mongo_replica_set").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.MongoReplicaSet{}
		}
		out := &sdm.MongoReplicaSet{
			ID:               d.Id(),
			Name:             convertStringFromMap(raw, "name"),
			Tags:             convertTagsFromMap(raw, "tags"),
			Hostname:         convertStringFromMap(raw, "hostname"),
			AuthDatabase:     convertStringFromMap(raw, "auth_database"),
			Username:         convertStringFromMap(raw, "username"),
			Password:         convertStringFromMap(raw, "password"),
			Port:             convertInt32FromMap(raw, "port"),
			ReplicaSet:       convertStringFromMap(raw, "replica_set"),
			ConnectToReplica: convertBoolFromMap(raw, "connect_to_replica"),
			TlsRequired:      convertBoolFromMap(raw, "tls_required"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("mysql").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Mysql{}
		}
		out := &sdm.Mysql{
			ID:       d.Id(),
			Name:     convertStringFromMap(raw, "name"),
			Tags:     convertTagsFromMap(raw, "tags"),
			Hostname: convertStringFromMap(raw, "hostname"),
			Username: convertStringFromMap(raw, "username"),
			Password: convertStringFromMap(raw, "password"),
			Database: convertStringFromMap(raw, "database"),
			Port:     convertInt32FromMap(raw, "port"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("aurora_mysql").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AuroraMysql{}
		}
		out := &sdm.AuroraMysql{
			ID:       d.Id(),
			Name:     convertStringFromMap(raw, "name"),
			Tags:     convertTagsFromMap(raw, "tags"),
			Hostname: convertStringFromMap(raw, "hostname"),
			Username: convertStringFromMap(raw, "username"),
			Password: convertStringFromMap(raw, "password"),
			Database: convertStringFromMap(raw, "database"),
			Port:     convertInt32FromMap(raw, "port"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("clustrix").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Clustrix{}
		}
		out := &sdm.Clustrix{
			ID:       d.Id(),
			Name:     convertStringFromMap(raw, "name"),
			Tags:     convertTagsFromMap(raw, "tags"),
			Hostname: convertStringFromMap(raw, "hostname"),
			Username: convertStringFromMap(raw, "username"),
			Password: convertStringFromMap(raw, "password"),
			Database: convertStringFromMap(raw, "database"),
			Port:     convertInt32FromMap(raw, "port"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("maria").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Maria{}
		}
		out := &sdm.Maria{
			ID:       d.Id(),
			Name:     convertStringFromMap(raw, "name"),
			Tags:     convertTagsFromMap(raw, "tags"),
			Hostname: convertStringFromMap(raw, "hostname"),
			Username: convertStringFromMap(raw, "username"),
			Password: convertStringFromMap(raw, "password"),
			Database: convertStringFromMap(raw, "database"),
			Port:     convertInt32FromMap(raw, "port"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("memsql").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Memsql{}
		}
		out := &sdm.Memsql{
			ID:       d.Id(),
			Name:     convertStringFromMap(raw, "name"),
			Tags:     convertTagsFromMap(raw, "tags"),
			Hostname: convertStringFromMap(raw, "hostname"),
			Username: convertStringFromMap(raw, "username"),
			Password: convertStringFromMap(raw, "password"),
			Database: convertStringFromMap(raw, "database"),
			Port:     convertInt32FromMap(raw, "port"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("oracle").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Oracle{}
		}
		out := &sdm.Oracle{
			ID:          d.Id(),
			Name:        convertStringFromMap(raw, "name"),
			Tags:        convertTagsFromMap(raw, "tags"),
			Hostname:    convertStringFromMap(raw, "hostname"),
			Username:    convertStringFromMap(raw, "username"),
			Password:    convertStringFromMap(raw, "password"),
			Database:    convertStringFromMap(raw, "database"),
			Port:        convertInt32FromMap(raw, "port"),
			TlsRequired: convertBoolFromMap(raw, "tls_required"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("postgres").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Postgres{}
		}
		out := &sdm.Postgres{
			ID:               d.Id(),
			Name:             convertStringFromMap(raw, "name"),
			Tags:             convertTagsFromMap(raw, "tags"),
			Hostname:         convertStringFromMap(raw, "hostname"),
			Username:         convertStringFromMap(raw, "username"),
			Password:         convertStringFromMap(raw, "password"),
			Database:         convertStringFromMap(raw, "database"),
			Port:             convertInt32FromMap(raw, "port"),
			OverrideDatabase: convertBoolFromMap(raw, "override_database"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("aurora_postgres").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AuroraPostgres{}
		}
		out := &sdm.AuroraPostgres{
			ID:               d.Id(),
			Name:             convertStringFromMap(raw, "name"),
			Tags:             convertTagsFromMap(raw, "tags"),
			Hostname:         convertStringFromMap(raw, "hostname"),
			Username:         convertStringFromMap(raw, "username"),
			Password:         convertStringFromMap(raw, "password"),
			Database:         convertStringFromMap(raw, "database"),
			Port:             convertInt32FromMap(raw, "port"),
			OverrideDatabase: convertBoolFromMap(raw, "override_database"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("greenplum").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Greenplum{}
		}
		out := &sdm.Greenplum{
			ID:               d.Id(),
			Name:             convertStringFromMap(raw, "name"),
			Tags:             convertTagsFromMap(raw, "tags"),
			Hostname:         convertStringFromMap(raw, "hostname"),
			Username:         convertStringFromMap(raw, "username"),
			Password:         convertStringFromMap(raw, "password"),
			Database:         convertStringFromMap(raw, "database"),
			Port:             convertInt32FromMap(raw, "port"),
			OverrideDatabase: convertBoolFromMap(raw, "override_database"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("cockroach").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Cockroach{}
		}
		out := &sdm.Cockroach{
			ID:               d.Id(),
			Name:             convertStringFromMap(raw, "name"),
			Tags:             convertTagsFromMap(raw, "tags"),
			Hostname:         convertStringFromMap(raw, "hostname"),
			Username:         convertStringFromMap(raw, "username"),
			Password:         convertStringFromMap(raw, "password"),
			Database:         convertStringFromMap(raw, "database"),
			Port:             convertInt32FromMap(raw, "port"),
			OverrideDatabase: convertBoolFromMap(raw, "override_database"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("redshift").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Redshift{}
		}
		out := &sdm.Redshift{
			ID:               d.Id(),
			Name:             convertStringFromMap(raw, "name"),
			Tags:             convertTagsFromMap(raw, "tags"),
			Hostname:         convertStringFromMap(raw, "hostname"),
			Username:         convertStringFromMap(raw, "username"),
			Password:         convertStringFromMap(raw, "password"),
			Database:         convertStringFromMap(raw, "database"),
			Port:             convertInt32FromMap(raw, "port"),
			OverrideDatabase: convertBoolFromMap(raw, "override_database"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("citus").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Citus{}
		}
		out := &sdm.Citus{
			ID:               d.Id(),
			Name:             convertStringFromMap(raw, "name"),
			Tags:             convertTagsFromMap(raw, "tags"),
			Hostname:         convertStringFromMap(raw, "hostname"),
			Username:         convertStringFromMap(raw, "username"),
			Password:         convertStringFromMap(raw, "password"),
			Database:         convertStringFromMap(raw, "database"),
			Port:             convertInt32FromMap(raw, "port"),
			OverrideDatabase: convertBoolFromMap(raw, "override_database"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("presto").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Presto{}
		}
		out := &sdm.Presto{
			ID:          d.Id(),
			Name:        convertStringFromMap(raw, "name"),
			Tags:        convertTagsFromMap(raw, "tags"),
			Hostname:    convertStringFromMap(raw, "hostname"),
			Password:    convertStringFromMap(raw, "password"),
			Database:    convertStringFromMap(raw, "database"),
			Port:        convertInt32FromMap(raw, "port"),
			Username:    convertStringFromMap(raw, "username"),
			TlsRequired: convertBoolFromMap(raw, "tls_required"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("rdp").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.RDP{}
		}
		out := &sdm.RDP{
			ID:       d.Id(),
			Name:     convertStringFromMap(raw, "name"),
			Tags:     convertTagsFromMap(raw, "tags"),
			Hostname: convertStringFromMap(raw, "hostname"),
			Username: convertStringFromMap(raw, "username"),
			Password: convertStringFromMap(raw, "password"),
			Port:     convertInt32FromMap(raw, "port"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("redis").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Redis{}
		}
		out := &sdm.Redis{
			ID:       d.Id(),
			Name:     convertStringFromMap(raw, "name"),
			Tags:     convertTagsFromMap(raw, "tags"),
			Hostname: convertStringFromMap(raw, "hostname"),
			Password: convertStringFromMap(raw, "password"),
			Port:     convertInt32FromMap(raw, "port"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("elasticache_redis").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.ElasticacheRedis{}
		}
		out := &sdm.ElasticacheRedis{
			ID:          d.Id(),
			Name:        convertStringFromMap(raw, "name"),
			Tags:        convertTagsFromMap(raw, "tags"),
			Hostname:    convertStringFromMap(raw, "hostname"),
			Password:    convertStringFromMap(raw, "password"),
			Port:        convertInt32FromMap(raw, "port"),
			TlsRequired: convertBoolFromMap(raw, "tls_required"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("snowflake").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Snowflake{}
		}
		out := &sdm.Snowflake{
			ID:       d.Id(),
			Name:     convertStringFromMap(raw, "name"),
			Tags:     convertTagsFromMap(raw, "tags"),
			Hostname: convertStringFromMap(raw, "hostname"),
			Username: convertStringFromMap(raw, "username"),
			Password: convertStringFromMap(raw, "password"),
			Database: convertStringFromMap(raw, "database"),
			Schema:   convertStringFromMap(raw, "schema"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("sql_server").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.SQLServer{}
		}
		out := &sdm.SQLServer{
			ID:               d.Id(),
			Name:             convertStringFromMap(raw, "name"),
			Tags:             convertTagsFromMap(raw, "tags"),
			Hostname:         convertStringFromMap(raw, "hostname"),
			Username:         convertStringFromMap(raw, "username"),
			Password:         convertStringFromMap(raw, "password"),
			Database:         convertStringFromMap(raw, "database"),
			Schema:           convertStringFromMap(raw, "schema"),
			Port:             convertInt32FromMap(raw, "port"),
			OverrideDatabase: convertBoolFromMap(raw, "override_database"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("ssh").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.SSH{}
		}
		out := &sdm.SSH{
			ID:                          d.Id(),
			Name:                        convertStringFromMap(raw, "name"),
			Tags:                        convertTagsFromMap(raw, "tags"),
			Hostname:                    convertStringFromMap(raw, "hostname"),
			Username:                    convertStringFromMap(raw, "username"),
			Port:                        convertInt32FromMap(raw, "port"),
			PortForwarding:              convertBoolFromMap(raw, "port_forwarding"),
			AllowDeprecatedKeyExchanges: convertBoolFromMap(raw, "allow_deprecated_key_exchanges"),
		}
		return out
	}
	if list := d.Get("ssh_cert").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.SSHCert{}
		}
		out := &sdm.SSHCert{
			ID:                          d.Id(),
			Name:                        convertStringFromMap(raw, "name"),
			Tags:                        convertTagsFromMap(raw, "tags"),
			Hostname:                    convertStringFromMap(raw, "hostname"),
			Username:                    convertStringFromMap(raw, "username"),
			Port:                        convertInt32FromMap(raw, "port"),
			PortForwarding:              convertBoolFromMap(raw, "port_forwarding"),
			AllowDeprecatedKeyExchanges: convertBoolFromMap(raw, "allow_deprecated_key_exchanges"),
		}
		return out
	}
	if list := d.Get("sybase").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Sybase{}
		}
		out := &sdm.Sybase{
			ID:       d.Id(),
			Name:     convertStringFromMap(raw, "name"),
			Tags:     convertTagsFromMap(raw, "tags"),
			Hostname: convertStringFromMap(raw, "hostname"),
			Username: convertStringFromMap(raw, "username"),
			Port:     convertInt32FromMap(raw, "port"),
			Password: convertStringFromMap(raw, "password"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("sybase_iq").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.SybaseIQ{}
		}
		out := &sdm.SybaseIQ{
			ID:       d.Id(),
			Name:     convertStringFromMap(raw, "name"),
			Tags:     convertTagsFromMap(raw, "tags"),
			Hostname: convertStringFromMap(raw, "hostname"),
			Username: convertStringFromMap(raw, "username"),
			Port:     convertInt32FromMap(raw, "port"),
			Password: convertStringFromMap(raw, "password"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("teradata").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Teradata{}
		}
		out := &sdm.Teradata{
			ID:       d.Id(),
			Name:     convertStringFromMap(raw, "name"),
			Tags:     convertTagsFromMap(raw, "tags"),
			Hostname: convertStringFromMap(raw, "hostname"),
			Username: convertStringFromMap(raw, "username"),
			Password: convertStringFromMap(raw, "password"),
			Port:     convertInt32FromMap(raw, "port"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	return nil
}

func resourceResourceCreate(d *schema.ResourceData, cc *sdm.Client) error {
	ctx, cancel := context.WithTimeout(context.Background(), d.Timeout(schema.TimeoutCreate))
	defer cancel()
	localVersion := convertResourceFromResourceData(d)
	resp, err := cc.Resources().Create(ctx, localVersion)
	if err != nil {
		return fmt.Errorf("cannot create Resource %s: %w", "", err)
	}
	d.SetId(resp.Resource.GetID())
	switch v := resp.Resource.(type) {
	case *sdm.Athena:
		localV, _ := localVersion.(*sdm.Athena)
		_ = localV
		d.Set("athena", []map[string]interface{}{
			{
				"name":              (v.Name),
				"tags":              convertTagsToMap(v.Tags),
				"access_key":        (v.AccessKey),
				"secret_access_key": localV.SecretAccessKey,
				"output":            (v.Output),
				"port_override":     (v.PortOverride),
				"region":            (v.Region),
			},
		})
	case *sdm.BigQuery:
		localV, _ := localVersion.(*sdm.BigQuery)
		_ = localV
		d.Set("big_query", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"private_key":   localV.PrivateKey,
				"project":       (v.Project),
				"port_override": (v.PortOverride),
				"endpoint":      (v.Endpoint),
				"username":      (v.Username),
			},
		})
	case *sdm.Cassandra:
		localV, _ := localVersion.(*sdm.Cassandra)
		_ = localV
		d.Set("cassandra", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"username":      (v.Username),
				"password":      localV.Password,
				"port_override": (v.PortOverride),
				"port":          (v.Port),
				"tls_required":  (v.TlsRequired),
			},
		})
	case *sdm.DB2I:
		localV, _ := localVersion.(*sdm.DB2I)
		_ = localV
		d.Set("db_2_i", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"username":      (v.Username),
				"password":      localV.Password,
				"database":      (v.Database),
				"port_override": (v.PortOverride),
				"port":          (v.Port),
				"tls_required":  (v.TlsRequired),
			},
		})
	case *sdm.DB2LUW:
		localV, _ := localVersion.(*sdm.DB2LUW)
		_ = localV
		d.Set("db_2_luw", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"username":      (v.Username),
				"password":      localV.Password,
				"database":      (v.Database),
				"port_override": (v.PortOverride),
				"port":          (v.Port),
			},
		})
	case *sdm.Druid:
		localV, _ := localVersion.(*sdm.Druid)
		_ = localV
		d.Set("druid", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"port_override": (v.PortOverride),
				"username":      (v.Username),
				"password":      localV.Password,
				"port":          (v.Port),
			},
		})
	case *sdm.DynamoDB:
		localV, _ := localVersion.(*sdm.DynamoDB)
		_ = localV
		d.Set("dynamo_db", []map[string]interface{}{
			{
				"name":              (v.Name),
				"tags":              convertTagsToMap(v.Tags),
				"access_key":        (v.AccessKey),
				"secret_access_key": localV.SecretAccessKey,
				"region":            (v.Region),
				"endpoint":          (v.Endpoint),
				"port_override":     (v.PortOverride),
			},
		})
	case *sdm.AmazonES:
		localV, _ := localVersion.(*sdm.AmazonES)
		_ = localV
		d.Set("amazon_es", []map[string]interface{}{
			{
				"name":              (v.Name),
				"tags":              convertTagsToMap(v.Tags),
				"region":            (v.Region),
				"secret_access_key": localV.SecretAccessKey,
				"endpoint":          (v.Endpoint),
				"access_key":        (v.AccessKey),
				"port_override":     (v.PortOverride),
			},
		})
	case *sdm.Elastic:
		localV, _ := localVersion.(*sdm.Elastic)
		_ = localV
		d.Set("elastic", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"username":      (v.Username),
				"password":      localV.Password,
				"port_override": (v.PortOverride),
				"port":          (v.Port),
				"tls_required":  (v.TlsRequired),
			},
		})
	case *sdm.HTTPBasicAuth:
		localV, _ := localVersion.(*sdm.HTTPBasicAuth)
		_ = localV
		d.Set("http_basic_auth", []map[string]interface{}{
			{
				"name":              (v.Name),
				"tags":              convertTagsToMap(v.Tags),
				"url":               (v.Url),
				"healthcheck_path":  (v.HealthcheckPath),
				"username":          (v.Username),
				"password":          localV.Password,
				"headers_blacklist": (v.HeadersBlacklist),
				"default_path":      (v.DefaultPath),
				"subdomain":         (v.Subdomain),
			},
		})
	case *sdm.HTTPNoAuth:
		localV, _ := localVersion.(*sdm.HTTPNoAuth)
		_ = localV
		d.Set("http_no_auth", []map[string]interface{}{
			{
				"name":              (v.Name),
				"tags":              convertTagsToMap(v.Tags),
				"url":               (v.Url),
				"healthcheck_path":  (v.HealthcheckPath),
				"headers_blacklist": (v.HeadersBlacklist),
				"default_path":      (v.DefaultPath),
				"subdomain":         (v.Subdomain),
			},
		})
	case *sdm.HTTPAuth:
		localV, _ := localVersion.(*sdm.HTTPAuth)
		_ = localV
		d.Set("http_auth", []map[string]interface{}{
			{
				"name":              (v.Name),
				"tags":              convertTagsToMap(v.Tags),
				"url":               (v.Url),
				"healthcheck_path":  (v.HealthcheckPath),
				"auth_header":       localV.AuthHeader,
				"headers_blacklist": (v.HeadersBlacklist),
				"default_path":      (v.DefaultPath),
				"subdomain":         (v.Subdomain),
			},
		})
	case *sdm.Kubernetes:
		localV, _ := localVersion.(*sdm.Kubernetes)
		_ = localV
		d.Set("kubernetes", []map[string]interface{}{
			{
				"name":                           (v.Name),
				"tags":                           convertTagsToMap(v.Tags),
				"hostname":                       (v.Hostname),
				"port":                           (v.Port),
				"certificate_authority":          localV.CertificateAuthority,
				"certificate_authority_filename": (v.CertificateAuthorityFilename),
				"client_certificate":             localV.ClientCertificate,
				"client_certificate_filename":    (v.ClientCertificateFilename),
				"client_key":                     localV.ClientKey,
				"client_key_filename":            (v.ClientKeyFilename),
				"healthcheck_namespace":          (v.HealthcheckNamespace),
			},
		})
	case *sdm.KubernetesBasicAuth:
		localV, _ := localVersion.(*sdm.KubernetesBasicAuth)
		_ = localV
		d.Set("kubernetes_basic_auth", []map[string]interface{}{
			{
				"name":                  (v.Name),
				"tags":                  convertTagsToMap(v.Tags),
				"hostname":              (v.Hostname),
				"port":                  (v.Port),
				"username":              (v.Username),
				"password":              localV.Password,
				"healthcheck_namespace": (v.HealthcheckNamespace),
			},
		})
	case *sdm.KubernetesServiceAccount:
		localV, _ := localVersion.(*sdm.KubernetesServiceAccount)
		_ = localV
		d.Set("kubernetes_service_account", []map[string]interface{}{
			{
				"name":                  (v.Name),
				"tags":                  convertTagsToMap(v.Tags),
				"hostname":              (v.Hostname),
				"port":                  (v.Port),
				"token":                 localV.Token,
				"healthcheck_namespace": (v.HealthcheckNamespace),
			},
		})
	case *sdm.AmazonEKS:
		localV, _ := localVersion.(*sdm.AmazonEKS)
		_ = localV
		d.Set("amazon_eks", []map[string]interface{}{
			{
				"name":                           (v.Name),
				"tags":                           convertTagsToMap(v.Tags),
				"endpoint":                       (v.Endpoint),
				"access_key":                     (v.AccessKey),
				"secret_access_key":              localV.SecretAccessKey,
				"certificate_authority":          localV.CertificateAuthority,
				"certificate_authority_filename": (v.CertificateAuthorityFilename),
				"region":                         (v.Region),
				"cluster_name":                   (v.ClusterName),
				"role_arn":                       (v.RoleArn),
				"healthcheck_namespace":          (v.HealthcheckNamespace),
			},
		})
	case *sdm.GoogleGKE:
		localV, _ := localVersion.(*sdm.GoogleGKE)
		_ = localV
		d.Set("google_gke", []map[string]interface{}{
			{
				"name":                           (v.Name),
				"tags":                           convertTagsToMap(v.Tags),
				"endpoint":                       (v.Endpoint),
				"certificate_authority":          localV.CertificateAuthority,
				"certificate_authority_filename": (v.CertificateAuthorityFilename),
				"service_account_key":            localV.ServiceAccountKey,
				"service_account_key_filename":   (v.ServiceAccountKeyFilename),
				"healthcheck_namespace":          (v.HealthcheckNamespace),
			},
		})
	case *sdm.AKS:
		localV, _ := localVersion.(*sdm.AKS)
		_ = localV
		d.Set("aks", []map[string]interface{}{
			{
				"name":                           (v.Name),
				"tags":                           convertTagsToMap(v.Tags),
				"hostname":                       (v.Hostname),
				"port":                           (v.Port),
				"certificate_authority":          localV.CertificateAuthority,
				"certificate_authority_filename": (v.CertificateAuthorityFilename),
				"client_certificate":             localV.ClientCertificate,
				"client_certificate_filename":    (v.ClientCertificateFilename),
				"client_key":                     localV.ClientKey,
				"client_key_filename":            (v.ClientKeyFilename),
				"healthcheck_namespace":          (v.HealthcheckNamespace),
			},
		})
	case *sdm.AKSBasicAuth:
		localV, _ := localVersion.(*sdm.AKSBasicAuth)
		_ = localV
		d.Set("aks_basic_auth", []map[string]interface{}{
			{
				"name":                  (v.Name),
				"tags":                  convertTagsToMap(v.Tags),
				"hostname":              (v.Hostname),
				"port":                  (v.Port),
				"username":              (v.Username),
				"password":              localV.Password,
				"healthcheck_namespace": (v.HealthcheckNamespace),
			},
		})
	case *sdm.AKSServiceAccount:
		localV, _ := localVersion.(*sdm.AKSServiceAccount)
		_ = localV
		d.Set("aks_service_account", []map[string]interface{}{
			{
				"name":                  (v.Name),
				"tags":                  convertTagsToMap(v.Tags),
				"hostname":              (v.Hostname),
				"port":                  (v.Port),
				"token":                 localV.Token,
				"healthcheck_namespace": (v.HealthcheckNamespace),
			},
		})
	case *sdm.Memcached:
		localV, _ := localVersion.(*sdm.Memcached)
		_ = localV
		d.Set("memcached", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"port_override": (v.PortOverride),
				"port":          (v.Port),
			},
		})
	case *sdm.MongoLegacyHost:
		localV, _ := localVersion.(*sdm.MongoLegacyHost)
		_ = localV
		d.Set("mongo_legacy_host", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"auth_database": (v.AuthDatabase),
				"port_override": (v.PortOverride),
				"username":      (v.Username),
				"password":      localV.Password,
				"port":          (v.Port),
				"replica_set":   (v.ReplicaSet),
				"tls_required":  (v.TlsRequired),
			},
		})
	case *sdm.MongoLegacyReplicaset:
		localV, _ := localVersion.(*sdm.MongoLegacyReplicaset)
		_ = localV
		d.Set("mongo_legacy_replicaset", []map[string]interface{}{
			{
				"name":               (v.Name),
				"tags":               convertTagsToMap(v.Tags),
				"hostname":           (v.Hostname),
				"auth_database":      (v.AuthDatabase),
				"port_override":      (v.PortOverride),
				"username":           (v.Username),
				"password":           localV.Password,
				"port":               (v.Port),
				"replica_set":        (v.ReplicaSet),
				"connect_to_replica": (v.ConnectToReplica),
				"tls_required":       (v.TlsRequired),
			},
		})
	case *sdm.MongoHost:
		localV, _ := localVersion.(*sdm.MongoHost)
		_ = localV
		d.Set("mongo_host", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"auth_database": (v.AuthDatabase),
				"port_override": (v.PortOverride),
				"username":      (v.Username),
				"password":      localV.Password,
				"port":          (v.Port),
				"tls_required":  (v.TlsRequired),
			},
		})
	case *sdm.MongoReplicaSet:
		localV, _ := localVersion.(*sdm.MongoReplicaSet)
		_ = localV
		d.Set("mongo_replica_set", []map[string]interface{}{
			{
				"name":               (v.Name),
				"tags":               convertTagsToMap(v.Tags),
				"hostname":           (v.Hostname),
				"auth_database":      (v.AuthDatabase),
				"port_override":      (v.PortOverride),
				"username":           (v.Username),
				"password":           localV.Password,
				"port":               (v.Port),
				"replica_set":        (v.ReplicaSet),
				"connect_to_replica": (v.ConnectToReplica),
				"tls_required":       (v.TlsRequired),
			},
		})
	case *sdm.Mysql:
		localV, _ := localVersion.(*sdm.Mysql)
		_ = localV
		d.Set("mysql", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"username":      (v.Username),
				"password":      localV.Password,
				"database":      (v.Database),
				"port_override": (v.PortOverride),
				"port":          (v.Port),
			},
		})
	case *sdm.AuroraMysql:
		localV, _ := localVersion.(*sdm.AuroraMysql)
		_ = localV
		d.Set("aurora_mysql", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"username":      (v.Username),
				"password":      localV.Password,
				"database":      (v.Database),
				"port_override": (v.PortOverride),
				"port":          (v.Port),
			},
		})
	case *sdm.Clustrix:
		localV, _ := localVersion.(*sdm.Clustrix)
		_ = localV
		d.Set("clustrix", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"username":      (v.Username),
				"password":      localV.Password,
				"database":      (v.Database),
				"port_override": (v.PortOverride),
				"port":          (v.Port),
			},
		})
	case *sdm.Maria:
		localV, _ := localVersion.(*sdm.Maria)
		_ = localV
		d.Set("maria", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"username":      (v.Username),
				"password":      localV.Password,
				"database":      (v.Database),
				"port_override": (v.PortOverride),
				"port":          (v.Port),
			},
		})
	case *sdm.Memsql:
		localV, _ := localVersion.(*sdm.Memsql)
		_ = localV
		d.Set("memsql", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"username":      (v.Username),
				"password":      localV.Password,
				"database":      (v.Database),
				"port_override": (v.PortOverride),
				"port":          (v.Port),
			},
		})
	case *sdm.Oracle:
		localV, _ := localVersion.(*sdm.Oracle)
		_ = localV
		d.Set("oracle", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"username":      (v.Username),
				"password":      localV.Password,
				"database":      (v.Database),
				"port":          (v.Port),
				"port_override": (v.PortOverride),
				"tls_required":  (v.TlsRequired),
			},
		})
	case *sdm.Postgres:
		localV, _ := localVersion.(*sdm.Postgres)
		_ = localV
		d.Set("postgres", []map[string]interface{}{
			{
				"name":              (v.Name),
				"tags":              convertTagsToMap(v.Tags),
				"hostname":          (v.Hostname),
				"username":          (v.Username),
				"password":          localV.Password,
				"database":          (v.Database),
				"port_override":     (v.PortOverride),
				"port":              (v.Port),
				"override_database": (v.OverrideDatabase),
			},
		})
	case *sdm.AuroraPostgres:
		localV, _ := localVersion.(*sdm.AuroraPostgres)
		_ = localV
		d.Set("aurora_postgres", []map[string]interface{}{
			{
				"name":              (v.Name),
				"tags":              convertTagsToMap(v.Tags),
				"hostname":          (v.Hostname),
				"username":          (v.Username),
				"password":          localV.Password,
				"database":          (v.Database),
				"port_override":     (v.PortOverride),
				"port":              (v.Port),
				"override_database": (v.OverrideDatabase),
			},
		})
	case *sdm.Greenplum:
		localV, _ := localVersion.(*sdm.Greenplum)
		_ = localV
		d.Set("greenplum", []map[string]interface{}{
			{
				"name":              (v.Name),
				"tags":              convertTagsToMap(v.Tags),
				"hostname":          (v.Hostname),
				"username":          (v.Username),
				"password":          localV.Password,
				"database":          (v.Database),
				"port_override":     (v.PortOverride),
				"port":              (v.Port),
				"override_database": (v.OverrideDatabase),
			},
		})
	case *sdm.Cockroach:
		localV, _ := localVersion.(*sdm.Cockroach)
		_ = localV
		d.Set("cockroach", []map[string]interface{}{
			{
				"name":              (v.Name),
				"tags":              convertTagsToMap(v.Tags),
				"hostname":          (v.Hostname),
				"username":          (v.Username),
				"password":          localV.Password,
				"database":          (v.Database),
				"port_override":     (v.PortOverride),
				"port":              (v.Port),
				"override_database": (v.OverrideDatabase),
			},
		})
	case *sdm.Redshift:
		localV, _ := localVersion.(*sdm.Redshift)
		_ = localV
		d.Set("redshift", []map[string]interface{}{
			{
				"name":              (v.Name),
				"tags":              convertTagsToMap(v.Tags),
				"hostname":          (v.Hostname),
				"username":          (v.Username),
				"password":          localV.Password,
				"database":          (v.Database),
				"port_override":     (v.PortOverride),
				"port":              (v.Port),
				"override_database": (v.OverrideDatabase),
			},
		})
	case *sdm.Citus:
		localV, _ := localVersion.(*sdm.Citus)
		_ = localV
		d.Set("citus", []map[string]interface{}{
			{
				"name":              (v.Name),
				"tags":              convertTagsToMap(v.Tags),
				"hostname":          (v.Hostname),
				"username":          (v.Username),
				"password":          localV.Password,
				"database":          (v.Database),
				"port_override":     (v.PortOverride),
				"port":              (v.Port),
				"override_database": (v.OverrideDatabase),
			},
		})
	case *sdm.Presto:
		localV, _ := localVersion.(*sdm.Presto)
		_ = localV
		d.Set("presto", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"password":      localV.Password,
				"database":      (v.Database),
				"port_override": (v.PortOverride),
				"port":          (v.Port),
				"username":      (v.Username),
				"tls_required":  (v.TlsRequired),
			},
		})
	case *sdm.RDP:
		localV, _ := localVersion.(*sdm.RDP)
		_ = localV
		d.Set("rdp", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"username":      (v.Username),
				"password":      localV.Password,
				"port_override": (v.PortOverride),
				"port":          (v.Port),
			},
		})
	case *sdm.Redis:
		localV, _ := localVersion.(*sdm.Redis)
		_ = localV
		d.Set("redis", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"port_override": (v.PortOverride),
				"password":      localV.Password,
				"port":          (v.Port),
			},
		})
	case *sdm.ElasticacheRedis:
		localV, _ := localVersion.(*sdm.ElasticacheRedis)
		_ = localV
		d.Set("elasticache_redis", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"port_override": (v.PortOverride),
				"password":      localV.Password,
				"port":          (v.Port),
				"tls_required":  (v.TlsRequired),
			},
		})
	case *sdm.Snowflake:
		localV, _ := localVersion.(*sdm.Snowflake)
		_ = localV
		d.Set("snowflake", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"username":      (v.Username),
				"password":      localV.Password,
				"database":      (v.Database),
				"schema":        (v.Schema),
				"port_override": (v.PortOverride),
			},
		})
	case *sdm.SQLServer:
		localV, _ := localVersion.(*sdm.SQLServer)
		_ = localV
		d.Set("sql_server", []map[string]interface{}{
			{
				"name":              (v.Name),
				"tags":              convertTagsToMap(v.Tags),
				"hostname":          (v.Hostname),
				"username":          (v.Username),
				"password":          localV.Password,
				"database":          (v.Database),
				"port_override":     (v.PortOverride),
				"schema":            (v.Schema),
				"port":              (v.Port),
				"override_database": (v.OverrideDatabase),
			},
		})
	case *sdm.SSH:
		localV, _ := localVersion.(*sdm.SSH)
		_ = localV
		d.Set("ssh", []map[string]interface{}{
			{
				"name":                           (v.Name),
				"tags":                           convertTagsToMap(v.Tags),
				"hostname":                       (v.Hostname),
				"username":                       (v.Username),
				"port":                           (v.Port),
				"public_key":                     (v.PublicKey),
				"port_forwarding":                (v.PortForwarding),
				"allow_deprecated_key_exchanges": (v.AllowDeprecatedKeyExchanges),
			},
		})
	case *sdm.SSHCert:
		localV, _ := localVersion.(*sdm.SSHCert)
		_ = localV
		d.Set("ssh_cert", []map[string]interface{}{
			{
				"name":                           (v.Name),
				"tags":                           convertTagsToMap(v.Tags),
				"hostname":                       (v.Hostname),
				"username":                       (v.Username),
				"port":                           (v.Port),
				"port_forwarding":                (v.PortForwarding),
				"allow_deprecated_key_exchanges": (v.AllowDeprecatedKeyExchanges),
			},
		})
	case *sdm.Sybase:
		localV, _ := localVersion.(*sdm.Sybase)
		_ = localV
		d.Set("sybase", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"username":      (v.Username),
				"port_override": (v.PortOverride),
				"port":          (v.Port),
				"password":      localV.Password,
			},
		})
	case *sdm.SybaseIQ:
		localV, _ := localVersion.(*sdm.SybaseIQ)
		_ = localV
		d.Set("sybase_iq", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"username":      (v.Username),
				"port_override": (v.PortOverride),
				"port":          (v.Port),
				"password":      localV.Password,
			},
		})
	case *sdm.Teradata:
		localV, _ := localVersion.(*sdm.Teradata)
		_ = localV
		d.Set("teradata", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"username":      (v.Username),
				"password":      localV.Password,
				"port_override": (v.PortOverride),
				"port":          (v.Port),
			},
		})
	}
	return nil
}

func resourceResourceRead(d *schema.ResourceData, cc *sdm.Client) error {
	ctx, cancel := context.WithTimeout(context.Background(), d.Timeout(schema.TimeoutRead))
	defer cancel()
	localVersion := convertResourceFromResourceData(d)
	_ = localVersion
	resp, err := cc.Resources().Get(ctx, d.Id())
	var errNotFound *sdm.NotFoundError
	if err != nil && errors.As(err, &errNotFound) {
		d.SetId("")
		return nil
	} else if err != nil {
		return fmt.Errorf("cannot read Resource %s: %w", d.Id(), err)
	}
	switch v := resp.Resource.(type) {
	case *sdm.Athena:
		localV, ok := localVersion.(*sdm.Athena)
		if !ok {
			localV = &sdm.Athena{}
		}
		_ = localV
		d.Set("athena", []map[string]interface{}{
			{
				"name":              (v.Name),
				"tags":              convertTagsToMap(v.Tags),
				"access_key":        (v.AccessKey),
				"secret_access_key": localV.SecretAccessKey,
				"output":            (v.Output),
				"port_override":     (v.PortOverride),
				"region":            (v.Region),
			},
		})
	case *sdm.BigQuery:
		localV, ok := localVersion.(*sdm.BigQuery)
		if !ok {
			localV = &sdm.BigQuery{}
		}
		_ = localV
		d.Set("big_query", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"private_key":   localV.PrivateKey,
				"project":       (v.Project),
				"port_override": (v.PortOverride),
				"endpoint":      (v.Endpoint),
				"username":      (v.Username),
			},
		})
	case *sdm.Cassandra:
		localV, ok := localVersion.(*sdm.Cassandra)
		if !ok {
			localV = &sdm.Cassandra{}
		}
		_ = localV
		d.Set("cassandra", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"username":      (v.Username),
				"password":      localV.Password,
				"port_override": (v.PortOverride),
				"port":          (v.Port),
				"tls_required":  (v.TlsRequired),
			},
		})
	case *sdm.DB2I:
		localV, ok := localVersion.(*sdm.DB2I)
		if !ok {
			localV = &sdm.DB2I{}
		}
		_ = localV
		d.Set("db_2_i", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"username":      (v.Username),
				"password":      localV.Password,
				"database":      (v.Database),
				"port_override": (v.PortOverride),
				"port":          (v.Port),
				"tls_required":  (v.TlsRequired),
			},
		})
	case *sdm.DB2LUW:
		localV, ok := localVersion.(*sdm.DB2LUW)
		if !ok {
			localV = &sdm.DB2LUW{}
		}
		_ = localV
		d.Set("db_2_luw", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"username":      (v.Username),
				"password":      localV.Password,
				"database":      (v.Database),
				"port_override": (v.PortOverride),
				"port":          (v.Port),
			},
		})
	case *sdm.Druid:
		localV, ok := localVersion.(*sdm.Druid)
		if !ok {
			localV = &sdm.Druid{}
		}
		_ = localV
		d.Set("druid", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"port_override": (v.PortOverride),
				"username":      (v.Username),
				"password":      localV.Password,
				"port":          (v.Port),
			},
		})
	case *sdm.DynamoDB:
		localV, ok := localVersion.(*sdm.DynamoDB)
		if !ok {
			localV = &sdm.DynamoDB{}
		}
		_ = localV
		d.Set("dynamo_db", []map[string]interface{}{
			{
				"name":              (v.Name),
				"tags":              convertTagsToMap(v.Tags),
				"access_key":        (v.AccessKey),
				"secret_access_key": localV.SecretAccessKey,
				"region":            (v.Region),
				"endpoint":          (v.Endpoint),
				"port_override":     (v.PortOverride),
			},
		})
	case *sdm.AmazonES:
		localV, ok := localVersion.(*sdm.AmazonES)
		if !ok {
			localV = &sdm.AmazonES{}
		}
		_ = localV
		d.Set("amazon_es", []map[string]interface{}{
			{
				"name":              (v.Name),
				"tags":              convertTagsToMap(v.Tags),
				"region":            (v.Region),
				"secret_access_key": localV.SecretAccessKey,
				"endpoint":          (v.Endpoint),
				"access_key":        (v.AccessKey),
				"port_override":     (v.PortOverride),
			},
		})
	case *sdm.Elastic:
		localV, ok := localVersion.(*sdm.Elastic)
		if !ok {
			localV = &sdm.Elastic{}
		}
		_ = localV
		d.Set("elastic", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"username":      (v.Username),
				"password":      localV.Password,
				"port_override": (v.PortOverride),
				"port":          (v.Port),
				"tls_required":  (v.TlsRequired),
			},
		})
	case *sdm.HTTPBasicAuth:
		localV, ok := localVersion.(*sdm.HTTPBasicAuth)
		if !ok {
			localV = &sdm.HTTPBasicAuth{}
		}
		_ = localV
		d.Set("http_basic_auth", []map[string]interface{}{
			{
				"name":              (v.Name),
				"tags":              convertTagsToMap(v.Tags),
				"url":               (v.Url),
				"healthcheck_path":  (v.HealthcheckPath),
				"username":          (v.Username),
				"password":          localV.Password,
				"headers_blacklist": (v.HeadersBlacklist),
				"default_path":      (v.DefaultPath),
				"subdomain":         (v.Subdomain),
			},
		})
	case *sdm.HTTPNoAuth:
		localV, ok := localVersion.(*sdm.HTTPNoAuth)
		if !ok {
			localV = &sdm.HTTPNoAuth{}
		}
		_ = localV
		d.Set("http_no_auth", []map[string]interface{}{
			{
				"name":              (v.Name),
				"tags":              convertTagsToMap(v.Tags),
				"url":               (v.Url),
				"healthcheck_path":  (v.HealthcheckPath),
				"headers_blacklist": (v.HeadersBlacklist),
				"default_path":      (v.DefaultPath),
				"subdomain":         (v.Subdomain),
			},
		})
	case *sdm.HTTPAuth:
		localV, ok := localVersion.(*sdm.HTTPAuth)
		if !ok {
			localV = &sdm.HTTPAuth{}
		}
		_ = localV
		d.Set("http_auth", []map[string]interface{}{
			{
				"name":              (v.Name),
				"tags":              convertTagsToMap(v.Tags),
				"url":               (v.Url),
				"healthcheck_path":  (v.HealthcheckPath),
				"auth_header":       localV.AuthHeader,
				"headers_blacklist": (v.HeadersBlacklist),
				"default_path":      (v.DefaultPath),
				"subdomain":         (v.Subdomain),
			},
		})
	case *sdm.Kubernetes:
		localV, ok := localVersion.(*sdm.Kubernetes)
		if !ok {
			localV = &sdm.Kubernetes{}
		}
		_ = localV
		d.Set("kubernetes", []map[string]interface{}{
			{
				"name":                           (v.Name),
				"tags":                           convertTagsToMap(v.Tags),
				"hostname":                       (v.Hostname),
				"port":                           (v.Port),
				"certificate_authority":          localV.CertificateAuthority,
				"certificate_authority_filename": (v.CertificateAuthorityFilename),
				"client_certificate":             localV.ClientCertificate,
				"client_certificate_filename":    (v.ClientCertificateFilename),
				"client_key":                     localV.ClientKey,
				"client_key_filename":            (v.ClientKeyFilename),
				"healthcheck_namespace":          (v.HealthcheckNamespace),
			},
		})
	case *sdm.KubernetesBasicAuth:
		localV, ok := localVersion.(*sdm.KubernetesBasicAuth)
		if !ok {
			localV = &sdm.KubernetesBasicAuth{}
		}
		_ = localV
		d.Set("kubernetes_basic_auth", []map[string]interface{}{
			{
				"name":                  (v.Name),
				"tags":                  convertTagsToMap(v.Tags),
				"hostname":              (v.Hostname),
				"port":                  (v.Port),
				"username":              (v.Username),
				"password":              localV.Password,
				"healthcheck_namespace": (v.HealthcheckNamespace),
			},
		})
	case *sdm.KubernetesServiceAccount:
		localV, ok := localVersion.(*sdm.KubernetesServiceAccount)
		if !ok {
			localV = &sdm.KubernetesServiceAccount{}
		}
		_ = localV
		d.Set("kubernetes_service_account", []map[string]interface{}{
			{
				"name":                  (v.Name),
				"tags":                  convertTagsToMap(v.Tags),
				"hostname":              (v.Hostname),
				"port":                  (v.Port),
				"token":                 localV.Token,
				"healthcheck_namespace": (v.HealthcheckNamespace),
			},
		})
	case *sdm.AmazonEKS:
		localV, ok := localVersion.(*sdm.AmazonEKS)
		if !ok {
			localV = &sdm.AmazonEKS{}
		}
		_ = localV
		d.Set("amazon_eks", []map[string]interface{}{
			{
				"name":                           (v.Name),
				"tags":                           convertTagsToMap(v.Tags),
				"endpoint":                       (v.Endpoint),
				"access_key":                     (v.AccessKey),
				"secret_access_key":              localV.SecretAccessKey,
				"certificate_authority":          localV.CertificateAuthority,
				"certificate_authority_filename": (v.CertificateAuthorityFilename),
				"region":                         (v.Region),
				"cluster_name":                   (v.ClusterName),
				"role_arn":                       (v.RoleArn),
				"healthcheck_namespace":          (v.HealthcheckNamespace),
			},
		})
	case *sdm.GoogleGKE:
		localV, ok := localVersion.(*sdm.GoogleGKE)
		if !ok {
			localV = &sdm.GoogleGKE{}
		}
		_ = localV
		d.Set("google_gke", []map[string]interface{}{
			{
				"name":                           (v.Name),
				"tags":                           convertTagsToMap(v.Tags),
				"endpoint":                       (v.Endpoint),
				"certificate_authority":          localV.CertificateAuthority,
				"certificate_authority_filename": (v.CertificateAuthorityFilename),
				"service_account_key":            localV.ServiceAccountKey,
				"service_account_key_filename":   (v.ServiceAccountKeyFilename),
				"healthcheck_namespace":          (v.HealthcheckNamespace),
			},
		})
	case *sdm.AKS:
		localV, ok := localVersion.(*sdm.AKS)
		if !ok {
			localV = &sdm.AKS{}
		}
		_ = localV
		d.Set("aks", []map[string]interface{}{
			{
				"name":                           (v.Name),
				"tags":                           convertTagsToMap(v.Tags),
				"hostname":                       (v.Hostname),
				"port":                           (v.Port),
				"certificate_authority":          localV.CertificateAuthority,
				"certificate_authority_filename": (v.CertificateAuthorityFilename),
				"client_certificate":             localV.ClientCertificate,
				"client_certificate_filename":    (v.ClientCertificateFilename),
				"client_key":                     localV.ClientKey,
				"client_key_filename":            (v.ClientKeyFilename),
				"healthcheck_namespace":          (v.HealthcheckNamespace),
			},
		})
	case *sdm.AKSBasicAuth:
		localV, ok := localVersion.(*sdm.AKSBasicAuth)
		if !ok {
			localV = &sdm.AKSBasicAuth{}
		}
		_ = localV
		d.Set("aks_basic_auth", []map[string]interface{}{
			{
				"name":                  (v.Name),
				"tags":                  convertTagsToMap(v.Tags),
				"hostname":              (v.Hostname),
				"port":                  (v.Port),
				"username":              (v.Username),
				"password":              localV.Password,
				"healthcheck_namespace": (v.HealthcheckNamespace),
			},
		})
	case *sdm.AKSServiceAccount:
		localV, ok := localVersion.(*sdm.AKSServiceAccount)
		if !ok {
			localV = &sdm.AKSServiceAccount{}
		}
		_ = localV
		d.Set("aks_service_account", []map[string]interface{}{
			{
				"name":                  (v.Name),
				"tags":                  convertTagsToMap(v.Tags),
				"hostname":              (v.Hostname),
				"port":                  (v.Port),
				"token":                 localV.Token,
				"healthcheck_namespace": (v.HealthcheckNamespace),
			},
		})
	case *sdm.Memcached:
		localV, ok := localVersion.(*sdm.Memcached)
		if !ok {
			localV = &sdm.Memcached{}
		}
		_ = localV
		d.Set("memcached", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"port_override": (v.PortOverride),
				"port":          (v.Port),
			},
		})
	case *sdm.MongoLegacyHost:
		localV, ok := localVersion.(*sdm.MongoLegacyHost)
		if !ok {
			localV = &sdm.MongoLegacyHost{}
		}
		_ = localV
		d.Set("mongo_legacy_host", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"auth_database": (v.AuthDatabase),
				"port_override": (v.PortOverride),
				"username":      (v.Username),
				"password":      localV.Password,
				"port":          (v.Port),
				"replica_set":   (v.ReplicaSet),
				"tls_required":  (v.TlsRequired),
			},
		})
	case *sdm.MongoLegacyReplicaset:
		localV, ok := localVersion.(*sdm.MongoLegacyReplicaset)
		if !ok {
			localV = &sdm.MongoLegacyReplicaset{}
		}
		_ = localV
		d.Set("mongo_legacy_replicaset", []map[string]interface{}{
			{
				"name":               (v.Name),
				"tags":               convertTagsToMap(v.Tags),
				"hostname":           (v.Hostname),
				"auth_database":      (v.AuthDatabase),
				"port_override":      (v.PortOverride),
				"username":           (v.Username),
				"password":           localV.Password,
				"port":               (v.Port),
				"replica_set":        (v.ReplicaSet),
				"connect_to_replica": (v.ConnectToReplica),
				"tls_required":       (v.TlsRequired),
			},
		})
	case *sdm.MongoHost:
		localV, ok := localVersion.(*sdm.MongoHost)
		if !ok {
			localV = &sdm.MongoHost{}
		}
		_ = localV
		d.Set("mongo_host", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"auth_database": (v.AuthDatabase),
				"port_override": (v.PortOverride),
				"username":      (v.Username),
				"password":      localV.Password,
				"port":          (v.Port),
				"tls_required":  (v.TlsRequired),
			},
		})
	case *sdm.MongoReplicaSet:
		localV, ok := localVersion.(*sdm.MongoReplicaSet)
		if !ok {
			localV = &sdm.MongoReplicaSet{}
		}
		_ = localV
		d.Set("mongo_replica_set", []map[string]interface{}{
			{
				"name":               (v.Name),
				"tags":               convertTagsToMap(v.Tags),
				"hostname":           (v.Hostname),
				"auth_database":      (v.AuthDatabase),
				"port_override":      (v.PortOverride),
				"username":           (v.Username),
				"password":           localV.Password,
				"port":               (v.Port),
				"replica_set":        (v.ReplicaSet),
				"connect_to_replica": (v.ConnectToReplica),
				"tls_required":       (v.TlsRequired),
			},
		})
	case *sdm.Mysql:
		localV, ok := localVersion.(*sdm.Mysql)
		if !ok {
			localV = &sdm.Mysql{}
		}
		_ = localV
		d.Set("mysql", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"username":      (v.Username),
				"password":      localV.Password,
				"database":      (v.Database),
				"port_override": (v.PortOverride),
				"port":          (v.Port),
			},
		})
	case *sdm.AuroraMysql:
		localV, ok := localVersion.(*sdm.AuroraMysql)
		if !ok {
			localV = &sdm.AuroraMysql{}
		}
		_ = localV
		d.Set("aurora_mysql", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"username":      (v.Username),
				"password":      localV.Password,
				"database":      (v.Database),
				"port_override": (v.PortOverride),
				"port":          (v.Port),
			},
		})
	case *sdm.Clustrix:
		localV, ok := localVersion.(*sdm.Clustrix)
		if !ok {
			localV = &sdm.Clustrix{}
		}
		_ = localV
		d.Set("clustrix", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"username":      (v.Username),
				"password":      localV.Password,
				"database":      (v.Database),
				"port_override": (v.PortOverride),
				"port":          (v.Port),
			},
		})
	case *sdm.Maria:
		localV, ok := localVersion.(*sdm.Maria)
		if !ok {
			localV = &sdm.Maria{}
		}
		_ = localV
		d.Set("maria", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"username":      (v.Username),
				"password":      localV.Password,
				"database":      (v.Database),
				"port_override": (v.PortOverride),
				"port":          (v.Port),
			},
		})
	case *sdm.Memsql:
		localV, ok := localVersion.(*sdm.Memsql)
		if !ok {
			localV = &sdm.Memsql{}
		}
		_ = localV
		d.Set("memsql", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"username":      (v.Username),
				"password":      localV.Password,
				"database":      (v.Database),
				"port_override": (v.PortOverride),
				"port":          (v.Port),
			},
		})
	case *sdm.Oracle:
		localV, ok := localVersion.(*sdm.Oracle)
		if !ok {
			localV = &sdm.Oracle{}
		}
		_ = localV
		d.Set("oracle", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"username":      (v.Username),
				"password":      localV.Password,
				"database":      (v.Database),
				"port":          (v.Port),
				"port_override": (v.PortOverride),
				"tls_required":  (v.TlsRequired),
			},
		})
	case *sdm.Postgres:
		localV, ok := localVersion.(*sdm.Postgres)
		if !ok {
			localV = &sdm.Postgres{}
		}
		_ = localV
		d.Set("postgres", []map[string]interface{}{
			{
				"name":              (v.Name),
				"tags":              convertTagsToMap(v.Tags),
				"hostname":          (v.Hostname),
				"username":          (v.Username),
				"password":          localV.Password,
				"database":          (v.Database),
				"port_override":     (v.PortOverride),
				"port":              (v.Port),
				"override_database": (v.OverrideDatabase),
			},
		})
	case *sdm.AuroraPostgres:
		localV, ok := localVersion.(*sdm.AuroraPostgres)
		if !ok {
			localV = &sdm.AuroraPostgres{}
		}
		_ = localV
		d.Set("aurora_postgres", []map[string]interface{}{
			{
				"name":              (v.Name),
				"tags":              convertTagsToMap(v.Tags),
				"hostname":          (v.Hostname),
				"username":          (v.Username),
				"password":          localV.Password,
				"database":          (v.Database),
				"port_override":     (v.PortOverride),
				"port":              (v.Port),
				"override_database": (v.OverrideDatabase),
			},
		})
	case *sdm.Greenplum:
		localV, ok := localVersion.(*sdm.Greenplum)
		if !ok {
			localV = &sdm.Greenplum{}
		}
		_ = localV
		d.Set("greenplum", []map[string]interface{}{
			{
				"name":              (v.Name),
				"tags":              convertTagsToMap(v.Tags),
				"hostname":          (v.Hostname),
				"username":          (v.Username),
				"password":          localV.Password,
				"database":          (v.Database),
				"port_override":     (v.PortOverride),
				"port":              (v.Port),
				"override_database": (v.OverrideDatabase),
			},
		})
	case *sdm.Cockroach:
		localV, ok := localVersion.(*sdm.Cockroach)
		if !ok {
			localV = &sdm.Cockroach{}
		}
		_ = localV
		d.Set("cockroach", []map[string]interface{}{
			{
				"name":              (v.Name),
				"tags":              convertTagsToMap(v.Tags),
				"hostname":          (v.Hostname),
				"username":          (v.Username),
				"password":          localV.Password,
				"database":          (v.Database),
				"port_override":     (v.PortOverride),
				"port":              (v.Port),
				"override_database": (v.OverrideDatabase),
			},
		})
	case *sdm.Redshift:
		localV, ok := localVersion.(*sdm.Redshift)
		if !ok {
			localV = &sdm.Redshift{}
		}
		_ = localV
		d.Set("redshift", []map[string]interface{}{
			{
				"name":              (v.Name),
				"tags":              convertTagsToMap(v.Tags),
				"hostname":          (v.Hostname),
				"username":          (v.Username),
				"password":          localV.Password,
				"database":          (v.Database),
				"port_override":     (v.PortOverride),
				"port":              (v.Port),
				"override_database": (v.OverrideDatabase),
			},
		})
	case *sdm.Citus:
		localV, ok := localVersion.(*sdm.Citus)
		if !ok {
			localV = &sdm.Citus{}
		}
		_ = localV
		d.Set("citus", []map[string]interface{}{
			{
				"name":              (v.Name),
				"tags":              convertTagsToMap(v.Tags),
				"hostname":          (v.Hostname),
				"username":          (v.Username),
				"password":          localV.Password,
				"database":          (v.Database),
				"port_override":     (v.PortOverride),
				"port":              (v.Port),
				"override_database": (v.OverrideDatabase),
			},
		})
	case *sdm.Presto:
		localV, ok := localVersion.(*sdm.Presto)
		if !ok {
			localV = &sdm.Presto{}
		}
		_ = localV
		d.Set("presto", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"password":      localV.Password,
				"database":      (v.Database),
				"port_override": (v.PortOverride),
				"port":          (v.Port),
				"username":      (v.Username),
				"tls_required":  (v.TlsRequired),
			},
		})
	case *sdm.RDP:
		localV, ok := localVersion.(*sdm.RDP)
		if !ok {
			localV = &sdm.RDP{}
		}
		_ = localV
		d.Set("rdp", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"username":      (v.Username),
				"password":      localV.Password,
				"port_override": (v.PortOverride),
				"port":          (v.Port),
			},
		})
	case *sdm.Redis:
		localV, ok := localVersion.(*sdm.Redis)
		if !ok {
			localV = &sdm.Redis{}
		}
		_ = localV
		d.Set("redis", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"port_override": (v.PortOverride),
				"password":      localV.Password,
				"port":          (v.Port),
			},
		})
	case *sdm.ElasticacheRedis:
		localV, ok := localVersion.(*sdm.ElasticacheRedis)
		if !ok {
			localV = &sdm.ElasticacheRedis{}
		}
		_ = localV
		d.Set("elasticache_redis", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"port_override": (v.PortOverride),
				"password":      localV.Password,
				"port":          (v.Port),
				"tls_required":  (v.TlsRequired),
			},
		})
	case *sdm.Snowflake:
		localV, ok := localVersion.(*sdm.Snowflake)
		if !ok {
			localV = &sdm.Snowflake{}
		}
		_ = localV
		d.Set("snowflake", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"username":      (v.Username),
				"password":      localV.Password,
				"database":      (v.Database),
				"schema":        (v.Schema),
				"port_override": (v.PortOverride),
			},
		})
	case *sdm.SQLServer:
		localV, ok := localVersion.(*sdm.SQLServer)
		if !ok {
			localV = &sdm.SQLServer{}
		}
		_ = localV
		d.Set("sql_server", []map[string]interface{}{
			{
				"name":              (v.Name),
				"tags":              convertTagsToMap(v.Tags),
				"hostname":          (v.Hostname),
				"username":          (v.Username),
				"password":          localV.Password,
				"database":          (v.Database),
				"port_override":     (v.PortOverride),
				"schema":            (v.Schema),
				"port":              (v.Port),
				"override_database": (v.OverrideDatabase),
			},
		})
	case *sdm.SSH:
		localV, ok := localVersion.(*sdm.SSH)
		if !ok {
			localV = &sdm.SSH{}
		}
		_ = localV
		d.Set("ssh", []map[string]interface{}{
			{
				"name":                           (v.Name),
				"tags":                           convertTagsToMap(v.Tags),
				"hostname":                       (v.Hostname),
				"username":                       (v.Username),
				"port":                           (v.Port),
				"public_key":                     (v.PublicKey),
				"port_forwarding":                (v.PortForwarding),
				"allow_deprecated_key_exchanges": (v.AllowDeprecatedKeyExchanges),
			},
		})
	case *sdm.SSHCert:
		localV, ok := localVersion.(*sdm.SSHCert)
		if !ok {
			localV = &sdm.SSHCert{}
		}
		_ = localV
		d.Set("ssh_cert", []map[string]interface{}{
			{
				"name":                           (v.Name),
				"tags":                           convertTagsToMap(v.Tags),
				"hostname":                       (v.Hostname),
				"username":                       (v.Username),
				"port":                           (v.Port),
				"port_forwarding":                (v.PortForwarding),
				"allow_deprecated_key_exchanges": (v.AllowDeprecatedKeyExchanges),
			},
		})
	case *sdm.Sybase:
		localV, ok := localVersion.(*sdm.Sybase)
		if !ok {
			localV = &sdm.Sybase{}
		}
		_ = localV
		d.Set("sybase", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"username":      (v.Username),
				"port_override": (v.PortOverride),
				"port":          (v.Port),
				"password":      localV.Password,
			},
		})
	case *sdm.SybaseIQ:
		localV, ok := localVersion.(*sdm.SybaseIQ)
		if !ok {
			localV = &sdm.SybaseIQ{}
		}
		_ = localV
		d.Set("sybase_iq", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"username":      (v.Username),
				"port_override": (v.PortOverride),
				"port":          (v.Port),
				"password":      localV.Password,
			},
		})
	case *sdm.Teradata:
		localV, ok := localVersion.(*sdm.Teradata)
		if !ok {
			localV = &sdm.Teradata{}
		}
		_ = localV
		d.Set("teradata", []map[string]interface{}{
			{
				"name":          (v.Name),
				"tags":          convertTagsToMap(v.Tags),
				"hostname":      (v.Hostname),
				"username":      (v.Username),
				"password":      localV.Password,
				"port_override": (v.PortOverride),
				"port":          (v.Port),
			},
		})
	}
	return nil
}
func resourceResourceUpdate(d *schema.ResourceData, cc *sdm.Client) error {
	ctx, cancel := context.WithTimeout(context.Background(), d.Timeout(schema.TimeoutUpdate))
	defer cancel()
	resp, err := cc.Resources().Update(ctx, convertResourceFromResourceData(d))
	if err != nil {
		return fmt.Errorf("cannot update Resource %s: %w", d.Id(), err)
	}
	d.SetId(resp.Resource.GetID())
	return resourceResourceRead(d, cc)
}
func resourceResourceDelete(d *schema.ResourceData, cc *sdm.Client) error {
	ctx, cancel := context.WithTimeout(context.Background(), d.Timeout(schema.TimeoutDelete))
	defer cancel()
	var errNotFound *sdm.NotFoundError
	_, err := cc.Resources().Delete(ctx, d.Id())
	if err != nil && errors.As(err, &errNotFound) {
		return nil
	}
	return err
}
